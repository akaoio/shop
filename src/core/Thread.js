// This class is used by each thread (main thread, worker threads)
// We want all threads to have the same behaviors and procedures.
import { isPromise, clone } from "./Utils/data.js"
import { NODE } from "./Utils/environments.js"
import { Construct } from "./Construct.js"

export default class Thread {
    configs = {}

    initialized = false

    constructor() {
        // Set up global error handlers to prevent process exit
        if (NODE) {
            process.on("uncaughtException", (error) => {
                console.error("Uncaught Exception:", error)
            })
            process.on("unhandledRejection", (reason, promise) => {
                console.error("Unhandled Rejection at:", promise, "reason:", reason)
            })
        } else {
            globalThis.onerror = (message, source, lineno, colno, error) => {
                console.error("Global Error:", error || message)
                return true // Prevents the default error handling
            }
            globalThis.onunhandledrejection = (event) => {
                console.error("Unhandled Rejection:", event.reason)
                event.preventDefault()
            }
        }

        // On message received from main thread
        if (typeof onmessage !== "undefined") onmessage = (event) => this.process(event.data)
        if (NODE)
            import("worker_threads").then(({ parentPort }) => {
                if (!parentPort) return
                this.parent = parentPort
                this.parent.on("message", (data) => this.process(data))
            })
        Construct.Site().then(async () => {
            if (typeof this?.init === "function") await this.init()
            this.initialized = true
        })
    }

    process = (data = {}) => {
        // queue is id of the queue, generated by the threads manager at ./Threads.js when queue() is called
        const queue = data?.queue
        const method = data?.method
        const params = data?.params
        if (!method) return
        if (typeof this?.[method] !== "function") return console.error("Method not found", method)

        // Call the actual method with params
        const result = this[method](params)

        if (!result) return
        if (!queue) return this.send({ Lives: clone(result) })
        if (isPromise(result)) return result.then((data) => this.send({ queue, response: clone(data) })).catch((error) => console.error(error))
        else this.send({ queue, response: clone(result) })
    }

    // This method is used to send data to main thread
    send = async (data = {}) => {
        if (!data) return
        if (NODE && !this.parent) {
            const { parentPort } = await import("worker_threads")
            if (!parentPort) return
            this.parent = parentPort
        }
        const send = typeof postMessage === "function" ? postMessage.bind(globalThis) : this?.parent?.postMessage.bind(this.parent)
        if (!send) throw new Error("No postMessage function found")
        send(data)
    }
}

export { Thread }
