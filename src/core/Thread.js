/**
 * Thread base class for consistent behavior across all threads (main and workers).
 * Handles message processing, error management, and communication with parent thread.
 * Extends functionality to both Node.js worker threads and browser Web Workers.
 */

// This class is used by each thread (main thread, worker threads)
// We want all threads to have the same behaviors and procedures.
import { isPromise, clone } from "./Utils/data.js"
import { NODE } from "./Utils/environments.js"
import { Construct } from "./Construct.js"

export default class Thread {
    // Configuration object for this thread
    configs = {}

    // Flag to track initialization state
    initialized = false

    /**
     * Initialize thread with error handlers and message listeners.
     * Sets up platform-specific handlers for browser and Node.js environments.
     */
    constructor() {
        // Set up global error handlers to prevent process exit
        if (NODE) {
            // Node.js: Handle uncaught exceptions
            process.on("uncaughtException", (error) => {
                console.error("Uncaught Exception:", error)
            })
            // Node.js: Handle unhandled promise rejections
            process.on("unhandledRejection", (reason, promise) => {
                console.error("Unhandled Rejection at:", promise, "reason:", reason)
            })
        } else {
            // Browser: Global error handler for synchronous errors
            globalThis.onerror = (message, source, lineno, colno, error) => {
                console.error("Global Error:", error || message)
                return true // Prevents the default error handling
            }
            // Browser: Global handler for unhandled promise rejections
            globalThis.onunhandledrejection = (event) => {
                console.error("Unhandled Rejection:", event.reason)
                event.preventDefault()
            }
        }

        // Set up message handlers for receiving messages from parent thread
        // Browser Web Worker: listens for messages from main thread
        if (typeof onmessage !== "undefined") onmessage = (event) => this.process(event.data)
        // Node.js Worker Thread: set up parent port listener
        if (NODE)
            import("worker_threads").then(({ parentPort }) => {
                if (!parentPort) return
                this.parent = parentPort
                this.parent.on("message", (data) => this.process(data))
            })
        // Initialize site and thread (calls init() if defined)
        Construct.Site().then(async () => {
            if (typeof this?.init === "function") await this.init()
            this.initialized = true
        })
    }

    /**
     * Process incoming messages from parent thread.
     * Calls the specified method with params and sends response back.
     * @param {Object} data - Message data containing queue, method, and params
     */
    process = (data = {}) => {
        // queue is id of the queue, generated by the threads manager at ./Threads.js when queue() is called
        const queue = data?.queue
        const method = data?.method
        const params = data?.params
        if (!method) return
        if (typeof this?.[method] !== "function") return console.error("Method not found", method)

        // Call the actual method with params
        const result = this[method](params)

        if (!result) return
        // If no queue ID, this is a one-way message (Lives update)
        if (!queue) return this.send({ Lives: clone(result) })
        // If result is a promise, wait for it to resolve before sending response
        if (isPromise(result)) return result.then((data) => this.send({ queue, response: clone(data) })).catch((error) => console.error(error))
        // Synchronous result: send immediately
        else this.send({ queue, response: clone(result) })
    }

    /**
     * Send data to parent thread (main thread).
     * Works with both Node.js worker_threads and browser Web Workers.
     * @param {Object} data - Data to send to parent thread
     */
    send = async (data = {}) => {
        if (!data) return
        // Node.js: Get parent port if not already set
        if (NODE && !this.parent) {
            const { parentPort } = await import("worker_threads")
            if (!parentPort) return
            this.parent = parentPort
        }
        // Use postMessage for both browser and Node.js (with fallback for Node.js parent port)
        const send = typeof postMessage === "function" ? postMessage.bind(globalThis) : this?.parent?.postMessage.bind(this.parent)
        if (!send) throw new Error("No postMessage function found")
        send(data)
    }
}

export { Thread }
